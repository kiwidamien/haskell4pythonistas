<!DOCTYPE html>
<html lang="en">
<head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta name="generator" content="Pelican" />
        <title>Pascal's triangle and recursion</title>
        <link rel="stylesheet" href="https://kiwidamien.github.io/hs4py/theme/css/main.css" />
        <link href="https://kiwidamien.github.io/hs4py/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Haskell 4 Pythonistas Atom Feed" />
        <meta name="description" content="TBW" />
</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1><a href="https://kiwidamien.github.io/hs4py/">Haskell 4 Pythonistas</a></h1>
                <nav><ul>
                    <li><a href="https://kiwidamien.github.io/hs4py/category/exercise.html">Exercise</a></li>
                    <li class="active"><a href="https://kiwidamien.github.io/hs4py/category/exercises.html">Exercises</a></li>
                </ul></nav>
        </header><!-- /#banner -->
<section id="content" class="body">
  <article>
    <header>
      <h1 class="entry-title">
        <a href="https://kiwidamien.github.io/hs4py/pascals-triangle-and-recursion.html" rel="bookmark"
           title="Permalink to Pascal's triangle and recursion">Pascal's triangle and recursion</a></h1>
    </header>

    <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2023-07-03T00:00:00-07:00">
                Published: Mon 03 July 2023
        </abbr>

        <address class="vcard author">
                By                         <a class="url fn" href="https://kiwidamien.github.io/hs4py/author/damien-martin.html">Damien Martin</a>
        </address>
<p>In <a href="https://kiwidamien.github.io/hs4py/category/exercises.html">Exercises</a>.</p>

</footer><!-- /.post-info -->      <p>Pascal's triangle is a classic recurrion problem, defined by the recursion relation</p>
<pre class="code literal-block">
pascal_element(row, 0) = pascal_element(row, row) = 1,  x &gt;= 0
pascal_element(row, col) = pascal_element(row-1, col-1) + pascal_element(row-1, col)
</pre>
<p>There is an alternative formulation in terms of factorials, but for now let's pretend this is the only definition that we know about.</p>
<p>Like the Fibbonacci sequence, we see that each recursive call spawns two more calls, leading to exponential growth of runtime in a naive implementation.</p>
<div class="section" id="python-verison">
<h2>Python verison</h2>
<p>The python version of this code is pretty simply to implement, and can be gotten on the first try.</p>
<pre class="code python literal-block">
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span><span class="w">
</span><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">lru_cache</span><span class="w">


</span><span class="nd">&#64;lru_cache</span><span class="w">
</span><span class="k">def</span> <span class="nf">pascal_element</span><span class="p">(</span><span class="n">row</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">col</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span><span class="w">
</span>    <span class="k">if</span> <span class="n">row</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span><span class="w">
</span>        <span class="k">return</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">col</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span><span class="w">
</span>    <span class="k">if</span> <span class="n">col</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">col</span> <span class="o">==</span> <span class="n">row</span><span class="p">:</span><span class="w">
</span>        <span class="k">return</span> <span class="mi">1</span><span class="w">
</span>    <span class="k">return</span> <span class="n">pascal_element</span><span class="p">(</span><span class="n">row</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">col</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">pascal_element</span><span class="p">(</span><span class="n">row</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span><span class="w">


</span><span class="k">def</span> <span class="nf">pascal_row</span><span class="p">(</span><span class="n">row</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span><span class="w">
</span>    <span class="k">return</span> <span class="p">[</span><span class="n">pascal_element</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">row</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span><span class="w">


</span><span class="k">def</span> <span class="nf">pascal_triangle</span><span class="p">(</span><span class="n">row</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span><span class="w">
</span>    <span class="k">return</span> <span class="p">[</span><span class="n">pascal_row</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">row</span><span class="p">)]</span>
</pre>
<p>Stopping the exponential runtime is as simple as putting a <tt class="docutils literal">&#64;lru_cache</tt> decorator on the function! We have something that is pretty easy to read, and has good runtime performance.</p>
</div>
<div class="section" id="haskell-versions">
<h2>Haskell versions</h2>
<p>Let's start with a naive implementation of the recursive call in Haskell, similar to Python:</p>
<pre class="code haskell literal-block">
<span class="kr">module</span><span class="w"> </span><span class="nn">Triangle</span><span class="w"> </span><span class="p">(</span><span class="nf">rows</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w">

</span><span class="nf">pe</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w">
</span><span class="nf">pe</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="p">(</span><span class="n">c</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="n">c</span><span class="o">==</span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="kr">else</span><span class="w"> </span><span class="p">((</span><span class="n">pe</span><span class="w"> </span><span class="p">(</span><span class="n">r</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">c</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">pe</span><span class="w"> </span><span class="p">(</span><span class="n">r</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="n">c</span><span class="p">))</span><span class="w">


</span><span class="nf">perow</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="kt">Int</span><span class="p">]</span><span class="w">
</span><span class="nf">perow</span><span class="w"> </span><span class="n">n</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">[]</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="n">otherwise</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="n">pe</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">c</span><span class="o">|</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="n">n</span><span class="p">]]</span><span class="w">


</span><span class="nf">rows</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[[</span><span class="kt">Int</span><span class="p">]]</span><span class="w">
</span><span class="nf">rows</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="n">perow</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="n">x</span><span class="p">]]</span>
</pre>
<p>Unfortunately, I don't know a simple way of implementating a cache, so this function quickly becomes very slow to execute. On a relatively new mmaching, even 25 rows is quite slow!</p>
<div class="section" id="next-version-recursion-by-row">
<h3>Next version: recursion by row</h3>
<p>There is a clever way around this: instead of thinking about recurrsion at the <em>element</em> level, we can generate the who <strong>row</strong> using recursion instead</p>
<p>The key observations here are if we have a row of the triangle, like <tt class="docutils literal">[1, 4, 6, 4, 1]</tt>, we can get the next row by:</p>
<ol class="arabic">
<li><p class="first">Start with <tt class="docutils literal">1</tt></p>
</li>
<li><p class="first">Add the list to itself, shifted one place over:
.. code:: python</p>
<blockquote>
<p>[1, 4, 6, 4, 1]
[4, 6, 4, 1,] = [5, 10, 10, 5]  # drop the one</p>
</blockquote>
</li>
<li><p class="first">End with <tt class="docutils literal">1</tt></p>
</li>
</ol>
<p>Step 2 in Python would be &quot;zip the list with itself shifted one index, then add&quot;, which would be</p>
<pre class="code python literal-block">
<span class="n">step_2</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">prev</span><span class="p">[</span><span class="mi">1</span><span class="p">:])]</span><span class="w">
</span><span class="c1"># finishe the calculation</span><span class="w">
</span><span class="n">next_row</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">step_2</span> <span class="o">+</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</pre>
<p>The equivalent in Haskell is <tt class="docutils literal">zipWith</tt>:</p>
<pre class="code haskell literal-block">
<span class="nf">step_2</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">zipWith</span><span class="w"> </span><span class="p">(</span><span class="o">+</span><span class="p">)</span><span class="w"> </span><span class="n">prev</span><span class="w"> </span><span class="p">(</span><span class="n">tail</span><span class="w"> </span><span class="n">prev</span><span class="p">)</span><span class="w">

</span><span class="c1">-- or, doing the whole step</span><span class="w">
</span><span class="nf">nextRow</span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="kt">Int</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="kt">Int</span><span class="p">]</span><span class="w">
</span><span class="nf">nextRow</span><span class="w"> </span><span class="n">prev</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">1</span><span class="kt">:</span><span class="w"> </span><span class="n">zipWith</span><span class="w"> </span><span class="p">(</span><span class="o">+</span><span class="p">)</span><span class="w"> </span><span class="n">prev</span><span class="w"> </span><span class="p">(</span><span class="n">tail</span><span class="w"> </span><span class="n">prev</span><span class="p">)</span><span class="kt">:</span><span class="w"> </span><span class="mi">1</span>
</pre>
<p>We need some guard clauses (at the moment, there is nothing stopping us passing an empty list, which would create problems for <tt class="docutils literal">tail</tt>). We can also pass in any list, which is not what we would want -- we only want to be able to pass in lists from Pascal's triangle.</p>
<p>We can make this a private function, and implement <tt class="docutils literal">perow</tt> so it once again takes an Int:</p>
<pre class="code haskell literal-block">
<span class="nf">perow</span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="kt">Int</span><span class="p">]</span><span class="w">
</span><span class="nf">perow</span><span class="w"> </span><span class="n">n</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">[]</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="n">otherwise</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">nextRow</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">perow</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="w">
  </span><span class="kr">where</span><span class="w"> </span><span class="n">nextRow</span><span class="w"> </span><span class="n">prev</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">zipWith</span><span class="w"> </span><span class="p">(</span><span class="o">+</span><span class="p">)</span><span class="w"> </span><span class="n">prev</span><span class="w"> </span><span class="p">(</span><span class="n">tail</span><span class="w"> </span><span class="n">prev</span><span class="p">)</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</pre>
<p>If we want to select a particular element (i.e. implement <tt class="docutils literal">pe</tt>) we can do so by generating the row, and then selecting the element using the index.</p>
<p>Here is the program, rewritten to be recursive on rows instead:</p>
<pre class="code haskell literal-block">
<span class="kr">module</span><span class="w"> </span><span class="nn">Triangle</span><span class="w"> </span><span class="p">(</span><span class="nf">rows</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w">

</span><span class="nf">perow</span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="kt">Int</span><span class="p">]</span><span class="w">
</span><span class="nf">perow</span><span class="w"> </span><span class="n">n</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">[]</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="n">otherwise</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">nextRow</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">perow</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="w">
  </span><span class="kr">where</span><span class="w"> </span><span class="n">nextRow</span><span class="w"> </span><span class="n">prev</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">zipWith</span><span class="w"> </span><span class="p">(</span><span class="o">+</span><span class="p">)</span><span class="w"> </span><span class="n">prev</span><span class="w"> </span><span class="p">(</span><span class="n">tail</span><span class="w"> </span><span class="n">prev</span><span class="p">)</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w">

</span><span class="c1">-- Now generate the entire row, and select the desired element</span><span class="w">
</span><span class="c1">--</span><span class="w">
</span><span class="nf">pe</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w">
</span><span class="nf">pe</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="n">perow</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="o">!!</span><span class="w"> </span><span class="n">c</span><span class="w">


</span><span class="nf">rows</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[[</span><span class="kt">Int</span><span class="p">]]</span><span class="w">
</span><span class="nf">rows</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="n">perow</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="n">x</span><span class="p">]]</span>
</pre>
<p>Because we only <em>calculate</em> the row once, and reuse it in the recursive call, we are at linear time for calculating a row.</p>
<p>We still have an $O(n^2)$ for calculating the rows (because we still have no memoization).</p>
</div>
</div>

    </div><!-- /.entry-content -->

  </article>
</section>
        <section id="extras" class="body">
                <div class="blogroll">
                        <h2>links</h2>
                        <ul>
                            <li><a href="https://getpelican.com/">Pelican</a></li>
                            <li><a href="https://www.python.org/">Python.org</a></li>
                            <li><a href="https://palletsprojects.com/p/jinja/">Jinja2</a></li>
                            <li><a href="#">You can modify those links in your config file</a></li>
                        </ul>
                </div><!-- /.blogroll -->
                <div class="social">
                        <h2>social</h2>
                        <ul>
                            <li><a href="https://kiwidamien.github.io/hs4py/feeds/all.atom.xml" type="application/atom+xml" rel="alternate">atom feed</a></li>

                            <li><a href="#">You can add links in your config file</a></li>
                            <li><a href="#">Another social link</a></li>
                        </ul>
                </div><!-- /.social -->
        </section><!-- /#extras -->

        <footer id="contentinfo" class="body">
                <address id="about" class="vcard body">
                Proudly powered by <a href="https://getpelican.com/">Pelican</a>, which takes great advantage of <a href="https://www.python.org/">Python</a>.
                </address><!-- /#about -->

                <p>The theme is by <a href="https://www.smashingmagazine.com/2009/08/designing-a-html-5-layout-from-scratch/">Smashing Magazine</a>, thanks!</p>
        </footer><!-- /#contentinfo -->

</body>
</html>