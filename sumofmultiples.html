<!DOCTYPE html>
<html lang="en">
<head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta name="generator" content="Pelican" />
        <title>SumOfMultiples</title>
        <link rel="stylesheet" href="https://kiwidamien.github.io/hs4py/theme/css/main.css" />
        <link href="https://kiwidamien.github.io/hs4py/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Haskell 4 Pythonistas Atom Feed" />
        <meta name="description" content="Exercise demonstrating the Monad properties of Lists in Haskell via a contrived programming task." />
</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1><a href="https://kiwidamien.github.io/hs4py/">Haskell 4 Pythonistas</a></h1>
                <nav><ul>
                    <li><a href="https://kiwidamien.github.io/hs4py/pages/hs4py.html">hs4py</a></li>
                    <li class="active"><a href="https://kiwidamien.github.io/hs4py/category/exercise.html">Exercise</a></li>
                    <li><a href="https://kiwidamien.github.io/hs4py/category/exercises.html">Exercises</a></li>
                </ul></nav>
        </header><!-- /#banner -->
<section id="content" class="body">
  <article>
    <header>
      <h1 class="entry-title">
        <a href="https://kiwidamien.github.io/hs4py/sumofmultiples.html" rel="bookmark"
           title="Permalink to SumOfMultiples">SumOfMultiples</a></h1>
    </header>

    <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2023-06-27T17:00:00-07:00">
                Published: Tue 27 June 2023
        </abbr>

        <address class="vcard author">
                By                         <a class="url fn" href="https://kiwidamien.github.io/hs4py/author/damien-martin.html">Damien Martin</a>
        </address>
<p>In <a href="https://kiwidamien.github.io/hs4py/category/exercise.html">Exercise</a>.</p>

</footer><!-- /.post-info -->      <p>Here is a pretty artifical problem from Exercism called <a class="reference external" href="https://exercism.org/tracks/haskell/exercises/sum-of-multiples">&quot;Sum of Multiplies&quot;</a>.
It is one of those contrived exercises designed to show that you can carry out a simple task.
For us, it will be useful to write it out in Python, and use it as an example of how to get more comfortable with &quot;a list as a Monad&quot;.</p>
<p>The description of the problem is</p>
<blockquote>
<p>You work for a company that makes an online, fantasy-survival game.</p>
<p>When a player finishes a level, they are awarded energy points. The amount of energy awarded depends on which magical items the player found while exploring that level.</p>
<p>The rules for determining points are</p>
<ol class="arabic simple">
<li>For each item, take its base value and get all multiples less than the current level.</li>
<li>Add all the unique multiples together</li>
</ol>
</blockquote>
<p>So as an example, if we are on level 15 and have items with levels 3 and 4, then</p>
<pre class="code literal-block">
multiples of 3 less than 15: 3, 6, 9, 12
multiples of 4 less than 15: 4, 8, 12
sum of multiples = sum({3, 4, 6, 8, 9, 12}) = 42
</pre>
<p>where the second 12 is removed as a duplicate.</p>
<div class="section" id="python-version">
<h2>Python version</h2>
<p>A working implmentation in Python is not too bad</p>
<pre class="code python literal-block">
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span><span class="w">


</span><span class="k">def</span> <span class="nf">multiple</span><span class="p">(</span><span class="n">base</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">upper</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span><span class="w">
</span>    <span class="k">if</span> <span class="n">base</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span><span class="w">
</span>        <span class="k">return</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w">
</span>    <span class="k">if</span> <span class="n">base</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span><span class="w">
</span>        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Should only accept positive values for base&quot;</span><span class="p">)</span><span class="w">
</span>    <span class="n">accumulator</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w">
</span>    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span><span class="w">
</span>        <span class="n">candidate</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">accumulator</span><span class="p">)</span> <span class="o">*</span> <span class="n">base</span><span class="w">
</span>        <span class="k">if</span> <span class="n">candidate</span> <span class="o">&gt;=</span> <span class="n">upper</span><span class="p">:</span><span class="w">
</span>            <span class="k">return</span> <span class="n">accumulator</span><span class="w">
</span>        <span class="n">accumulator</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">candidate</span><span class="p">)</span><span class="w">


</span><span class="k">def</span> <span class="nf">sumOfMultiples</span><span class="p">(</span><span class="n">items</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">level</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span><span class="w">
</span>    <span class="n">multiples</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">multiple</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">upper</span><span class="o">=</span><span class="n">level</span><span class="p">)</span> <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="n">items</span><span class="p">],</span> <span class="p">[])</span><span class="w">
</span>    <span class="n">distinct_multiples</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">multiples</span><span class="p">)</span><span class="w">
</span>    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">distinct_multiples</span><span class="p">)</span>
</pre>
<p>We can call <tt class="docutils literal"><span class="pre">sumOfMultiples([3,</span> 4], 15)</tt> and verify that we get <tt class="docutils literal">42</tt>.</p>
<p>One critique I would have is the way the factors are collected. The idea of &quot;summing list of lists, starting with the empty list&quot; is my go to way of flattening a list in Python. It is a cool little one-liner, but could be confusing in this case because we are using <cite>sum</cite> again in the problem to sum numbers.</p>
<p>What the factors line is really doing is a reduce:</p>
<pre class="code python literal-block">
<span class="kn">import</span> <span class="nn">functools</span><span class="w">

</span><span class="c1"># replace factors = sum(....) above with this</span><span class="w">
</span><span class="n">factors</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">,</span> <span class="p">[</span><span class="n">multiple</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">upper</span><span class="o">=</span><span class="n">level</span><span class="p">)</span> <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="n">items</span><span class="p">],</span> <span class="p">[])</span>
</pre>
<p>You could also argue that the <tt class="docutils literal">multiples</tt> function should return a set of integers and not a list.
In this case, that is fair, but I would be writing this with the idea that maybe this function can be reused somewhere else.
It is easier to give the list of multiples ordered (because I generated them that way) and if the caller wants
them unordered to make that the caller's responsibility.</p>
</div>
<div class="section" id="haskell-versions">
<h2>Haskell versions</h2>
<p>One of the things that I find difficult about Haskell is relearning all the standard locations for functionality. Here we can use</p>
<pre class="code haskell literal-block">
<span class="kr">import</span><span class="w"> </span><span class="k">qualified</span><span class="w"> </span><span class="nn">Data.Set</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">S</span><span class="w">  </span><span class="c1">-- need qualification so Set map doesn't interfere with List map</span><span class="w">
</span><span class="c1">-- gives us S.fromList and S.toList</span>
</pre>
<div class="section" id="first-version">
<h3>First version</h3>
<p>Here I started with the multiples function, and got hooked on the idea of a clever infinite generator:</p>
<pre class="code haskell literal-block">
<span class="nf">multiples</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Integer</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="kt">Integer</span><span class="p">]</span><span class="w">
</span><span class="nf">multiples</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">m</span><span class="w">
    </span><span class="kr">where</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="n">zipWith</span><span class="w"> </span><span class="p">(</span><span class="o">+</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">repeat</span><span class="w"> </span><span class="n">n</span><span class="p">)</span>
</pre>
<p>This works through lasy evaluation. You want the first element? It's just <tt class="docutils literal">n</tt>!</p>
<p>How about the first two elements? Well the first one is <tt class="docutils literal">n</tt>.
The second one we need the first element from <tt class="docutils literal">zipWith (+) ([n, <span class="pre">?,?,?,</span> <span class="pre">....])</span> ([n, n, n, <span class="pre">....])</span> = <span class="pre">[n+n,?+n,...]</span></tt>.
Since we only need the first element, we don't have to worry about those question marks, so we get <tt class="docutils literal">[n, 2*n]</tt>.</p>
<p>The first three elements? We know that <tt class="docutils literal">m</tt> has <tt class="docutils literal">[n, 2*n]</tt> as it's first two elements. So the zipWith is actually</p>
<pre class="code haskell literal-block">
<span class="nf">m</span><span class="w"> </span><span class="n">evals</span><span class="w"> </span><span class="n">as</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="n">zipWith</span><span class="w"> </span><span class="p">(</span><span class="o">+</span><span class="p">)</span><span class="w"> </span><span class="p">([</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="o">...</span><span class="p">])</span><span class="w"> </span><span class="p">([</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">])</span><span class="w"> </span><span class="c1">-- expanding out the first two entries in m</span><span class="w">
        </span><span class="ow">=</span><span class="w"> </span><span class="n">n</span><span class="kt">:</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="o">.....</span><span class="w">  </span><span class="c1">-- eval the zipWith</span><span class="w">
        </span><span class="ow">=</span><span class="w"> </span><span class="n">n</span><span class="kt">:</span><span class="w"> </span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="mi">3</span><span class="o">*</span><span class="n">n</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="o">....</span><span class="w">         </span><span class="c1">-- if we are only taking the first three, lazy eval would stop here</span>
</pre>
<p>This is a cool Haskell-ish function, but we have put responsibility on the caller to know it generates an infinite sequence. Whenever we call it, we have to make sure that we don't evaluate the whole thing.</p>
<p>Mirroring the Python solution to get the multiples from the list of items:</p>
<pre class="code haskell literal-block">
<span class="nf">multiplesUpTo</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="kt">Integer</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Integer</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="kt">Integer</span><span class="p">]</span><span class="w">
</span><span class="nf">multiplesUpTo</span><span class="w"> </span><span class="n">items</span><span class="w"> </span><span class="n">limit</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">concat</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">map</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">n</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">takeWhile</span><span class="w"> </span><span class="p">(</span><span class="o">&lt;</span><span class="w"> </span><span class="n">limit</span><span class="p">)</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">multiples</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="n">items</span>
</pre>
<p>We can dedupe:</p>
<pre class="code haskell literal-block">
<span class="nf">uniqueMultiplesLessThen</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="kt">Integer</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Integer</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="kt">Integer</span><span class="p">]</span><span class="w">
</span><span class="nf">uniqueMultiplesLessThen</span><span class="w"> </span><span class="n">items</span><span class="w"> </span><span class="n">limit</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">S</span><span class="o">.</span><span class="n">toList</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="kt">S</span><span class="o">.</span><span class="n">fromList</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">multiplesUpTo</span><span class="w"> </span><span class="n">items</span><span class="w"> </span><span class="n">limit</span>
</pre>
<p>We can then sum and we are done!</p>
<div class="section" id="result">
<h4>Result</h4>
<pre class="code haskell literal-block">
<span class="kr">module</span><span class="w"> </span><span class="nn">SumOfMultiples</span><span class="w"> </span><span class="p">(</span><span class="nf">sumOfMultiples</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w">
</span><span class="kr">import</span><span class="w"> </span><span class="k">qualified</span><span class="w"> </span><span class="nn">Data.Set</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">S</span><span class="w">

</span><span class="nf">multiples</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Integer</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="kt">Integer</span><span class="p">]</span><span class="w">
</span><span class="nf">multiples</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">m</span><span class="w">
    </span><span class="kr">where</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="kt">:</span><span class="w"> </span><span class="n">zipWith</span><span class="w"> </span><span class="p">(</span><span class="o">+</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">repeat</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w">

</span><span class="c1">-- note: moved multiples inside uniqueMultiplesLess Than</span><span class="w">
</span><span class="nf">uniqueMultiplesLessThan</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="kt">Integer</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Integer</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="kt">Integer</span><span class="p">]</span><span class="w">
</span><span class="nf">uniqueMultiplesLessThan</span><span class="w"> </span><span class="n">factors</span><span class="w"> </span><span class="n">limit</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">S</span><span class="o">.</span><span class="n">toList</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="kt">S</span><span class="o">.</span><span class="n">fromList</span><span class="w"> </span><span class="n">m</span><span class="w">
    </span><span class="kr">where</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">concat</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">map</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">n</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">takeWhile</span><span class="w"> </span><span class="p">(</span><span class="o">&lt;</span><span class="w"> </span><span class="n">limit</span><span class="p">)</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">multiples</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="n">factors</span><span class="w">


</span><span class="nf">sumOfMultiples</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="kt">Integer</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Integer</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Integer</span><span class="w">
</span><span class="nf">sumOfMultiples</span><span class="w"> </span><span class="n">factors</span><span class="w"> </span><span class="n">limit</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">uniqueMultiplesLessThan</span><span class="w"> </span><span class="n">factors</span><span class="w"> </span><span class="n">limit</span>
</pre>
<p>There a quite a few problems with the code above! Let's go through them:</p>
<ol class="arabic simple">
<li>A item <tt class="docutils literal">[0]</tt> will cause the <tt class="docutils literal">takeWhile</tt> to run forever!</li>
<li>The <tt class="docutils literal">concat</tt> and <tt class="docutils literal">map</tt> next to each other is the sign of a beginning Haskeller!
The <tt class="docutils literal">map</tt> is transforming a my list of integers into a list of lists, and <tt class="docutils literal">concat</tt> is flattening it.
The idea of &quot;map and flatten&quot; are two of the monoid operations, so I should be able to generalize this code.</li>
</ol>
</div>
</div>
<div class="section" id="second-version-eliminate-the-infinite-loop">
<h3>Second version: Eliminate the infinite loop</h3>
<p>In this case, I was just trying to be too clever! There is a one-liner that bounds the result:</p>
<pre class="code haskell literal-block">
<span class="nf">multiplesUpTo</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Integer</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Integer</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="kt">Integer</span><span class="p">]</span><span class="w">
</span><span class="nf">multiplesUpTo</span><span class="w"> </span><span class="n">base</span><span class="w"> </span><span class="n">limit</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="n">mult</span><span class="o">*</span><span class="n">base</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">mult</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="n">limit</span><span class="p">],</span><span class="w"> </span><span class="n">mult</span><span class="o">*</span><span class="n">base</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">limit</span><span class="p">]</span>
</pre>
<p>I think if you take the entire list, it will do all <tt class="docutils literal">limit</tt> evaluations. Even with lazy evaluation, it has to do the evaluation to know that you don't
pass the condition.</p>
<p>If you do a <tt class="docutils literal">takeWhile (&lt; limit) $ multipleUpTo base limit</tt> the laziness will prevent the unnecessary computations.
Here you are using the fact that you know the results are ordered, so you can stop evaluating as soon as you first fail the condition.
It is a little weird that to get this optimization you need to specify the upper bound in two different places, though.</p>
<p>A slightly nicer way, is something like this</p>
<pre class="code haskell literal-block">
<span class="nf">multiplesUpTo</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Integer</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Integer</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="kt">Integer</span><span class="p">]</span><span class="w">
</span><span class="nf">multiplesUpTo</span><span class="w"> </span><span class="n">base</span><span class="w"> </span><span class="n">limit</span><span class="w">
    </span><span class="o">|</span><span class="w"> </span><span class="n">base</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w">
    </span><span class="o">|</span><span class="w"> </span><span class="n">base</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">limit</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w">
    </span><span class="o">|</span><span class="w"> </span><span class="n">otherwise</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">takeWhile</span><span class="w"> </span><span class="p">(</span><span class="o">&lt;</span><span class="w"> </span><span class="n">limit</span><span class="p">)</span><span class="w"> </span><span class="n">m</span><span class="w">
    </span><span class="kr">where</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">base</span><span class="kt">:</span><span class="w"> </span><span class="n">zipWith</span><span class="w"> </span><span class="p">(</span><span class="o">+</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">repeat</span><span class="w"> </span><span class="n">base</span><span class="p">)</span>
</pre>
<div class="section" id="result-1">
<h4>Result</h4>
<pre class="code haskell literal-block">
<span class="kr">module</span><span class="w"> </span><span class="nn">SumOfMultiples</span><span class="w"> </span><span class="p">(</span><span class="nf">sumOfMultiples</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w">
</span><span class="kr">import</span><span class="w"> </span><span class="k">qualified</span><span class="w"> </span><span class="nn">Data.Set</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">S</span><span class="w">

</span><span class="c1">-- use the slightly less efficent way</span><span class="w">
</span><span class="nf">multiplesUpTo</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Integer</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Integer</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="kt">Integer</span><span class="p">]</span><span class="w">
</span><span class="nf">multiplesUpTo</span><span class="w"> </span><span class="n">base</span><span class="w"> </span><span class="n">limit</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="n">mult</span><span class="o">*</span><span class="n">base</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">mult</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="n">limit</span><span class="p">],</span><span class="w"> </span><span class="n">mult</span><span class="o">*</span><span class="n">base</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">limit</span><span class="p">]</span><span class="w">

</span><span class="c1">-- note: moved multiples inside uniqueMultiplesLess Than</span><span class="w">
</span><span class="nf">uniqueMultiplesLessThan</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="kt">Integer</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Integer</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="kt">Integer</span><span class="p">]</span><span class="w">
</span><span class="nf">uniqueMultiplesLessThan</span><span class="w"> </span><span class="n">factors</span><span class="w"> </span><span class="n">limit</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">S</span><span class="o">.</span><span class="n">toList</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="kt">S</span><span class="o">.</span><span class="n">fromList</span><span class="w"> </span><span class="n">m</span><span class="w">
    </span><span class="kr">where</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">concat</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">map</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">n</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">multiplesUpTo</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">limit</span><span class="p">)</span><span class="w"> </span><span class="n">factors</span><span class="w">


</span><span class="nf">sumOfMultiples</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="kt">Integer</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Integer</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Integer</span><span class="w">
</span><span class="nf">sumOfMultiples</span><span class="w"> </span><span class="n">factors</span><span class="w"> </span><span class="n">limit</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">uniqueMultiplesLessThan</span><span class="w"> </span><span class="n">factors</span><span class="w"> </span><span class="n">limit</span>
</pre>
</div>
</div>
<div class="section" id="third-version-get-rid-of-concat-map-by-thinking-of-list-as-a-monad">
<h3>Third version: Get rid of <cite>concat map</cite> by thinking of list as a Monad</h3>
<p>Now we are looking at the line of code</p>
<pre class="code haskell literal-block">
<span class="nf">concat</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">map</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">n</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">multiplesUpTo</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">limit</span><span class="p">)</span><span class="w"> </span><span class="n">factors</span>
</pre>
<p>Working this through for our list of items [3,4] and limit of 15:</p>
<pre class="code haskell literal-block">
<span class="nf">concat</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">map</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">n</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">multiplesUpTo</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="mi">15</span><span class="p">)</span><span class="w"> </span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">]</span><span class="w">
</span><span class="nf">concat</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="p">[</span><span class="n">multiplesUpTo</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">15</span><span class="p">,</span><span class="w"> </span><span class="n">mutipliesUpTo</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">15</span><span class="p">]</span><span class="w">
</span><span class="nf">concat</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">9</span><span class="p">,</span><span class="w"> </span><span class="mi">12</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">12</span><span class="p">]]</span><span class="w">
</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">9</span><span class="p">,</span><span class="w"> </span><span class="mi">12</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">12</span><span class="p">]</span>
</pre>
<p>We also know that a list is a Monad. In this case we have <tt class="docutils literal">List Integer</tt>. We have four Monad functions, specialized to the list Monad:</p>
<ol class="arabic simple">
<li><strong>Unit</strong>: Given an <tt class="docutils literal">x</tt>, generate a list of <tt class="docutils literal">x</tt>; in this case <tt class="docutils literal">unit x = [x]</tt> is our unit.</li>
<li><strong>fmap</strong>: Given a function <tt class="docutils literal">g: X <span class="pre">-&gt;</span> Y</tt>, use <tt class="docutils literal">fmap</tt> to transform it into a function from <tt class="docutils literal">[X] <span class="pre">-&gt;</span> [Y]</tt>. This is precisely what <tt class="docutils literal">map</tt> does!</li>
<li><strong>join</strong>: An operation that removes the outer layer of the monad. In this case, we have <tt class="docutils literal">join: [[X]] <span class="pre">-&gt;</span> [X]</tt>, which is precisely what <tt class="docutils literal">concat</tt> does!</li>
<li><strong>bind</strong>: Transforms a function <tt class="docutils literal">f: X <span class="pre">-&gt;</span> [Y]</tt> to a new function <tt class="docutils literal">bind f: [X] <span class="pre">-&gt;</span> [Y]</tt>. In Haskell, this is <tt class="docutils literal">&gt;&gt;=</tt></li>
</ol>
<p>Note that <tt class="docutils literal">bind</tt> most closely resembles what we have in this case.</p>
<ul class="simple">
<li>Given a single <tt class="docutils literal">item</tt> we can generate a list of its multiples. So we have <tt class="docutils literal">f x = multiples x 15</tt>, for example, with signature <tt class="docutils literal">f :: Integer <span class="pre">-&gt;</span> [Integer]</tt></li>
<li>In our solution, we use <tt class="docutils literal">(map f) :: [Integer] <span class="pre">-&gt;</span> [[Integer]]</tt>; i.e. we feed <tt class="docutils literal">map f</tt> our list of items and we get back a nested list.</li>
<li>In our solution, we then use <tt class="docutils literal">concat</tt> (i.e. <tt class="docutils literal">join</tt>) to flatten the list, i.e. <tt class="docutils literal">concat $ map f:: [Integer] <span class="pre">-&gt;</span> [Integer]</tt>.</li>
</ul>
<p>Note that <tt class="docutils literal">concat $ map</tt> is a mapping takes a function <tt class="docutils literal"><span class="pre">g::X-&gt;Y</span></tt> and gives us <tt class="docutils literal">(concat $ map <span class="pre">g)::</span> [X] <span class="pre">-&gt;</span> [Y]</tt>. One of the monad identities is</p>
<p><tt class="docutils literal">join $ map</tt> is the same as <tt class="docutils literal">bind</tt> (recall <tt class="docutils literal">join</tt> for maps is <tt class="docutils literal">concat</tt> -- this is the generalized version)</p>
<p>So instead of writing</p>
<pre class="code haskell literal-block">
<span class="nf">concat</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">map</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">n</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">multiplesUpTo</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">limit</span><span class="p">)</span><span class="w"> </span><span class="n">factors</span>
</pre>
<p>we can write</p>
<pre class="code haskell literal-block">
<span class="nf">factors</span><span class="w"> </span><span class="o">&gt;&gt;=</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">n</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">multiplesUpTo</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">limit</span><span class="p">)</span>
</pre>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This arguably makes the code less clear <em>to those that are starting in Haskell</em>. The real benefit is that it takes something familiar to Python programmers (flattening a list, and mapping over values) and helps build our examples of &quot;what is a Monad?&quot; and &quot;what does bind do again?&quot;</p>
</div>
<p>We can do one other thing to tidy this function up. It would have been nice if we had defined the arguments <tt class="docutils literal">multiplesUpTo</tt> in the opposite order:
<tt class="docutils literal">limit</tt> first, then the number <tt class="docutils literal">s</tt>. Then instead of writing</p>
<pre class="code haskell literal-block">
<span class="nf">factors</span><span class="w"> </span><span class="o">&gt;&gt;=</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">n</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">multiplesUpTo</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">limit</span><span class="p">)</span>
</pre>
<p>we could write</p>
<pre class="code haskell literal-block">
<span class="nf">factors</span><span class="w"> </span><span class="o">&gt;&gt;=</span><span class="w"> </span><span class="p">(</span><span class="n">multiplesUpToWrittenOtherOrder</span><span class="w"> </span><span class="n">limit</span><span class="p">)</span>
</pre>
<p>The only purpose of the lambda function is to flip the order we apply the arguments. We can do this with <tt class="docutils literal">flip</tt>! So a slightly nicer looking version is</p>
<pre class="code haskell literal-block">
<span class="nf">factors</span><span class="w"> </span><span class="o">&gt;&gt;=</span><span class="w"> </span><span class="p">((</span><span class="n">flip</span><span class="w"> </span><span class="n">multiplesUpTo</span><span class="p">)</span><span class="w"> </span><span class="n">limit</span><span class="p">)</span>
</pre>
<div class="section" id="result-2">
<h4>Result</h4>
<pre class="code haskell literal-block">
<span class="kr">module</span><span class="w"> </span><span class="nn">SumOfMultiples</span><span class="w"> </span><span class="p">(</span><span class="nf">sumOfMultiples</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w">
</span><span class="kr">import</span><span class="w"> </span><span class="k">qualified</span><span class="w"> </span><span class="nn">Data.Set</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">S</span><span class="w">

</span><span class="c1">-- use the slightly less efficent way</span><span class="w">
</span><span class="nf">multiplesUpTo</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Integer</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Integer</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="kt">Integer</span><span class="p">]</span><span class="w">
</span><span class="nf">multiplesUpTo</span><span class="w"> </span><span class="n">base</span><span class="w"> </span><span class="n">limit</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="n">mult</span><span class="o">*</span><span class="n">base</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">mult</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="n">limit</span><span class="p">],</span><span class="w"> </span><span class="n">mult</span><span class="o">*</span><span class="n">base</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">limit</span><span class="p">]</span><span class="w">

</span><span class="c1">-- note: moved multiples inside uniqueMultiplesLess Than</span><span class="w">
</span><span class="nf">uniqueMultiplesLessThan</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="kt">Integer</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Integer</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="kt">Integer</span><span class="p">]</span><span class="w">
</span><span class="nf">uniqueMultiplesLessThan</span><span class="w"> </span><span class="n">factors</span><span class="w"> </span><span class="n">limit</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">S</span><span class="o">.</span><span class="n">toList</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="kt">S</span><span class="o">.</span><span class="n">fromList</span><span class="w"> </span><span class="n">m</span><span class="w">
    </span><span class="kr">where</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">factors</span><span class="w"> </span><span class="o">&gt;&gt;=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="n">flip</span><span class="w"> </span><span class="n">multiplesUpTo</span><span class="p">)</span><span class="w"> </span><span class="n">limit</span><span class="p">)</span><span class="w">


</span><span class="nf">sumOfMultiples</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="kt">Integer</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Integer</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Integer</span><span class="w">
</span><span class="nf">sumOfMultiples</span><span class="w"> </span><span class="n">factors</span><span class="w"> </span><span class="n">limit</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">uniqueMultiplesLessThan</span><span class="w"> </span><span class="n">factors</span><span class="w"> </span><span class="n">limit</span>
</pre>
</div>
</div>
</div>

    </div><!-- /.entry-content -->

  </article>
</section>
        <section id="extras" class="body">
                <div class="blogroll">
                        <h2>links</h2>
                        <ul>
                            <li><a href="https://getpelican.com/">Pelican</a></li>
                            <li><a href="https://www.python.org/">Python.org</a></li>
                            <li><a href="https://palletsprojects.com/p/jinja/">Jinja2</a></li>
                            <li><a href="#">You can modify those links in your config file</a></li>
                        </ul>
                </div><!-- /.blogroll -->
                <div class="social">
                        <h2>social</h2>
                        <ul>
                            <li><a href="https://kiwidamien.github.io/hs4py/feeds/all.atom.xml" type="application/atom+xml" rel="alternate">atom feed</a></li>

                            <li><a href="#">You can add links in your config file</a></li>
                            <li><a href="#">Another social link</a></li>
                        </ul>
                </div><!-- /.social -->
        </section><!-- /#extras -->

        <footer id="contentinfo" class="body">
                <address id="about" class="vcard body">
                Proudly powered by <a href="https://getpelican.com/">Pelican</a>, which takes great advantage of <a href="https://www.python.org/">Python</a>.
                </address><!-- /#about -->

                <p>The theme is by <a href="https://www.smashingmagazine.com/2009/08/designing-a-html-5-layout-from-scratch/">Smashing Magazine</a>, thanks!</p>
        </footer><!-- /#contentinfo -->

</body>
</html>