<!DOCTYPE html>
<html lang="en">
<head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta name="generator" content="Pelican" />
        <title>Haskell 4 Pythonistas - Exercises</title>
        <link rel="stylesheet" href="https://kiwidamien.github.io/hs4py/theme/css/main.css" />
        <link href="https://kiwidamien.github.io/hs4py/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Haskell 4 Pythonistas Atom Feed" />
</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1><a href="https://kiwidamien.github.io/hs4py/">Haskell 4 Pythonistas</a></h1>
                <nav><ul>
                    <li><a href="https://kiwidamien.github.io/hs4py/pages/hs4py.html">hs4py</a></li>
                    <li><a href="https://kiwidamien.github.io/hs4py/category/exercise.html">Exercise</a></li>
                    <li class="active"><a href="https://kiwidamien.github.io/hs4py/category/exercises.html">Exercises</a></li>
                </ul></nav>
        </header><!-- /#banner -->

            <aside id="featured" class="body">
                <article>
                    <h1 class="entry-title"><a href="https://kiwidamien.github.io/hs4py/making-change.html">Making Change</a></h1>
<footer class="post-info">
        <abbr class="published" title="2023-07-29T00:00:00-07:00">
                Published: Sat 29 July 2023
        </abbr>

        <address class="vcard author">
                By                         <a class="url fn" href="https://kiwidamien.github.io/hs4py/author/damien-martin.html">Damien Martin</a>
        </address>
<p>In <a href="https://kiwidamien.github.io/hs4py/category/exercises.html">Exercises</a>.</p>

</footer><!-- /.post-info --><p>Here we are trying to implement one piece of Minesweeper, which is to be able to render the board.
The biggest part that we need to implement is determining the number of mines adjacent to each cell (including diagonals).
This number is between 0 and 8 (because we don't check the cell itself, just its eight neighbours).</p>
<p>The actual function we are asked to implement is a function that will render the board, meaning it will take a list of strings with spaces and <cite>*</cite>, representing
empty cells and mines respectively. The function annotate will produce a list of strings, where the character in row <tt class="docutils literal">r</tt> and column <tt class="docutils literal">c</tt> is:</p>
<ul class="simple">
<li><tt class="docutils literal">*</tt> if it is the location of a mine</li>
<li>:code:` ` (i.e. space) if it is not a mine, nor adjacent to any mine (i.e. our helper function returns 0)</li>
<li>A digit <tt class="docutils literal">1</tt> - <tt class="docutils literal">8</tt> representing the number of adjacent mines</li>
</ul>
<p>For example</p>
<pre class="code python literal-block">
<span class="n">grid</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;      &quot;</span><span class="p">,</span><span class="w">
</span>        <span class="s2">&quot; *  * &quot;</span><span class="p">,</span><span class="w">
</span>        <span class="s2">&quot; *    &quot;</span><span class="p">,</span><span class="w">
</span>        <span class="s2">&quot;      &quot;</span><span class="p">,</span><span class="w">
</span>        <span class="s2">&quot;     *&quot;</span><span class="p">]</span><span class="w">
</span><span class="n">annotate</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span><span class="w">
</span><span class="c1"># Should be</span><span class="w">
</span><span class="c1">#      [&quot;111111&quot;,</span><span class="w">
</span><span class="c1">#       &quot;2*21*1&quot;,</span><span class="w">
</span><span class="c1">#       &quot;2*2111&quot;,</span><span class="w">
</span><span class="c1">#       &quot;111 11&quot;,</span><span class="w">
</span><span class="c1">#       &quot;    1*&quot;]</span>
</pre>
<div class="section" id="python-version-of-annotate">
<h2>Python version of <tt class="docutils literal">annotate</tt></h2>
<p>The implmentation here is pretty straightforward. One of the things that makes it a little tricky
is that we are not just writing out the number of adjacent mines, as there are special rules if the
location is itself a mine, or if the location is not adjacent to any mines. The other issue is the
potentially messy checking of boundary conditions.</p>
<p>The boundary conditions are fixed by indexing the locations we want to check, and catching an <tt class="docutils literal">IndexError</tt>
if one is raised.</p>
<p>The other simplification is that we can write our function that counts the number of
mines to count those at the current location _and_ the adjacent locations. If we are at the location of
a mine, this will make the number higher by 1 than if we wanted to just get the number of strictly adjacent mines,
but if we are on a mine location we don't use the number (we use the token <tt class="docutils literal">*</tt> instead).
We are free to implment our helper function as either a function that counts all mines in the neighborhood of the function,
or one that counts all mines in the neighborhood excluding itself.</p>
<pre class="code python literal-block">
<span class="k">def</span> <span class="nf">annotate</span><span class="p">(</span><span class="n">grid</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span><span class="w">
</span>    <span class="k">def</span> <span class="nf">num_to_char</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">num</span><span class="p">):</span><span class="w">
</span>        <span class="k">if</span> <span class="n">grid</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">]</span> <span class="o">==</span> <span class="s1">'*'</span><span class="p">:</span><span class="w">
</span>            <span class="k">return</span> <span class="s1">'*'</span><span class="w">
</span>        <span class="k">if</span> <span class="n">num</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span><span class="w">
</span>            <span class="k">return</span> <span class="s1">' '</span><span class="w">
</span>        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">num</span><span class="p">)</span><span class="w">

</span>    <span class="k">def</span> <span class="nf">count_stars</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">):</span><span class="w">
</span>        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="w">
</span>        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="p">[</span><span class="n">row</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">row</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span><span class="w">
</span>            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="n">col</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">col</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span><span class="w">
</span>                <span class="k">try</span><span class="p">:</span><span class="w">
</span>                    <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">grid</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">==</span> <span class="s1">'*'</span> <span class="k">else</span> <span class="mi">0</span><span class="w">
</span>                <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span><span class="w">
</span>                    <span class="k">pass</span><span class="w">
</span>        <span class="k">return</span> <span class="n">count</span><span class="w">

</span>    <span class="n">counter</span> <span class="o">=</span> <span class="p">[</span><span class="w">
</span>        <span class="p">[</span><span class="n">count_stars</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]))]</span><span class="w">
</span>        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">))</span><span class="w">
</span>    <span class="p">]</span><span class="w">
</span>    <span class="n">output</span> <span class="o">=</span> <span class="p">[</span><span class="w">
</span>        <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">num_to_char</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span> <span class="k">for</span> <span class="n">col</span><span class="p">,</span> <span class="n">num</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">row_contents</span><span class="p">)])</span><span class="w">
</span>        <span class="k">for</span> <span class="n">row</span><span class="p">,</span> <span class="n">row_contents</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">counter</span><span class="p">)</span><span class="w">
</span>    <span class="p">]</span><span class="w">
</span>    <span class="k">return</span> <span class="n">output</span>
</pre>
</div>
<div class="section" id="haskell-version">
<h2>Haskell version</h2>
<div class="section" id="first-attempt">
<h3>First attempt</h3>
<p>Let's start with a function that, given an array and a location, will extract out the
set of neighbors (generally a 3x3, but differs on the edges). We just want to produce them as a flat list.</p>
<p>We do this with a list comprehension:</p>
<pre class="code haskell literal-block">
<span class="nf">neighborhood</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[[</span><span class="n">a</span><span class="p">]]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w">
</span><span class="nf">neighborhood</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">[]</span><span class="w">
</span><span class="nf">neighborhood</span><span class="w"> </span><span class="n">row</span><span class="w"> </span><span class="n">col</span><span class="w"> </span><span class="n">grid</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="n">grid</span><span class="w"> </span><span class="o">!!</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">!!</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">|</span><span class="n">r</span><span class="ow">&lt;-</span><span class="p">[(</span><span class="n">row</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">..</span><span class="p">(</span><span class="n">row</span><span class="o">+</span><span class="mi">1</span><span class="p">)],</span><span class="w"> </span><span class="n">c</span><span class="ow">&lt;-</span><span class="p">[(</span><span class="n">col</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">..</span><span class="p">(</span><span class="n">col</span><span class="o">+</span><span class="mi">1</span><span class="p">)],</span><span class="w"> </span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">)</span><span class="o">/=</span><span class="p">(</span><span class="n">row</span><span class="p">,</span><span class="n">col</span><span class="p">),</span><span class="w"> </span><span class="n">r</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">r</span><span class="o">&lt;</span><span class="p">(</span><span class="n">length</span><span class="w"> </span><span class="n">grid</span><span class="p">),</span><span class="w"> </span><span class="n">c</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="o">&lt;</span><span class="n">length</span><span class="p">(</span><span class="n">grid</span><span class="o">!!</span><span class="mi">0</span><span class="p">)]</span>
</pre>
<p>The guard against <tt class="docutils literal">[]</tt> is needed because we get the number of columns by looking at the first row,
so we need to implement what happens if there is no first row.</p>
<p>This was the hardest function to write. A big part of it was resistance on my part of indexing
directly into the lists (twice!). I spent a long time thinking about how to zip the current row with
the previous and next rows to get the sum of the number of mines in adjacent rows.</p>
<p>Once we have the neighborhood, we can define the equivalent of <tt class="docutils literal">count_stars</tt> in the Python version.
We just need to be able to count the number of times the character <tt class="docutils literal">*</tt> appears.</p>
<pre class="code haskell literal-block">
<span class="c1">-- Same job as count_stars in Python code</span><span class="w">
</span><span class="nf">scoreCell</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[[</span><span class="kt">Char</span><span class="p">]]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w">
</span><span class="nf">scoreCell</span><span class="w"> </span><span class="n">row</span><span class="w"> </span><span class="n">col</span><span class="w"> </span><span class="n">grid</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">countOcc</span><span class="w"> </span><span class="sc">'*'</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">neighborhood</span><span class="w"> </span><span class="n">row</span><span class="w"> </span><span class="n">col</span><span class="w"> </span><span class="n">grid</span><span class="w">
    </span><span class="kr">where</span><span class="w"> </span><span class="n">countOcc</span><span class="w"> </span><span class="n">char</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">0</span><span class="w">
          </span><span class="n">countOcc</span><span class="w"> </span><span class="n">char</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="kr">if</span><span class="w"> </span><span class="n">x</span><span class="o">==</span><span class="n">char</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="kr">else</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">countOcc</span><span class="w"> </span><span class="n">char</span><span class="w"> </span><span class="n">xs</span><span class="p">)</span>
</pre>
<p>The helper <tt class="docutils literal">countOcc</tt> looks like a pretty generic Haskell function, taking a list
and counting the number of times a value appears.
Searching on <a class="reference external" href="https://hackage.haskell.org/package/MissingH-1.6.0.0/docs/src/Data.List.Utils.html#countElem">Hoogle</a>
I found <tt class="docutils literal">countElem</tt> with a much nicer implementation than mine.</p>
<pre class="code haskell literal-block">
<span class="c1">-- in Data.List.Utils</span><span class="w">
</span><span class="nf">countElem</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Eq</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w">
</span><span class="nf">countElem</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="n">filter</span><span class="w"> </span><span class="p">(</span><span class="n">value</span><span class="o">==</span><span class="p">)</span>
</pre>
<p>We can simplify <tt class="docutils literal">scoreCell</tt> to</p>
<pre class="code haskell literal-block">
<span class="c1">-- Same job as count_stars in Python code</span><span class="w">
</span><span class="nf">scoreCell</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[[</span><span class="kt">Char</span><span class="p">]]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w">
</span><span class="nf">scoreCell</span><span class="w"> </span><span class="n">row</span><span class="w"> </span><span class="n">col</span><span class="w"> </span><span class="n">grid</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">filter</span><span class="w"> </span><span class="p">(</span><span class="sc">'*'</span><span class="o">==</span><span class="p">)</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">neighborhood</span><span class="w"> </span><span class="n">row</span><span class="w"> </span><span class="n">col</span><span class="w"> </span><span class="n">grid</span>
</pre>
<p>The rest of the code is taking these functions and &quot;mapping&quot; them over the original board
to get the number of mines in the neighborhood of each cell, and then finally converting these
neighborhood numbers to characters (including the special rules for locations of mines, and places with no mines).</p>
<p>The complete program is here</p>
<pre class="code haskell literal-block">
<span class="kr">module</span><span class="w"> </span><span class="nn">Minesweeper</span><span class="w"> </span><span class="p">(</span><span class="nf">annotate</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w">
</span><span class="kr">import</span><span class="w"> </span><span class="nn">Data.Char</span><span class="w">

</span><span class="nf">neighborhood</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[[</span><span class="n">a</span><span class="p">]]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w">
</span><span class="nf">neighborhood</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">[]</span><span class="w">
</span><span class="nf">neighborhood</span><span class="w"> </span><span class="n">row</span><span class="w"> </span><span class="n">col</span><span class="w"> </span><span class="n">grid</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="n">grid</span><span class="w"> </span><span class="o">!!</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">!!</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">r</span><span class="ow">&lt;-</span><span class="p">[(</span><span class="n">row</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">..</span><span class="p">(</span><span class="n">row</span><span class="o">+</span><span class="mi">1</span><span class="p">)],</span><span class="w"> </span><span class="n">c</span><span class="ow">&lt;-</span><span class="p">[(</span><span class="n">col</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">..</span><span class="p">(</span><span class="n">col</span><span class="o">+</span><span class="mi">1</span><span class="p">)],</span><span class="w"> </span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">)</span><span class="o">/=</span><span class="p">(</span><span class="n">row</span><span class="p">,</span><span class="n">col</span><span class="p">),</span><span class="w"> </span><span class="n">r</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">r</span><span class="o">&lt;</span><span class="p">(</span><span class="n">length</span><span class="w"> </span><span class="n">grid</span><span class="p">),</span><span class="w"> </span><span class="n">c</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="o">&lt;</span><span class="n">length</span><span class="p">(</span><span class="n">grid</span><span class="o">!!</span><span class="mi">0</span><span class="p">)]</span><span class="w">

</span><span class="nf">scoreCell</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[[</span><span class="kt">Char</span><span class="p">]]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w">
</span><span class="nf">scoreCell</span><span class="w"> </span><span class="n">row</span><span class="w"> </span><span class="n">col</span><span class="w"> </span><span class="n">grid</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">filter</span><span class="w"> </span><span class="p">(</span><span class="sc">'*'</span><span class="o">==</span><span class="p">)</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">neighborhood</span><span class="w"> </span><span class="n">row</span><span class="w"> </span><span class="n">col</span><span class="w"> </span><span class="n">grid</span><span class="w">

</span><span class="nf">scoreGrid</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[[</span><span class="kt">Char</span><span class="p">]]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[[</span><span class="kt">Int</span><span class="p">]]</span><span class="w">
</span><span class="nf">scoreGrid</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">[]</span><span class="w">
</span><span class="nf">scoreGrid</span><span class="w"> </span><span class="n">grid</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[[</span><span class="n">scoreCell</span><span class="w"> </span><span class="n">row</span><span class="w"> </span><span class="n">col</span><span class="w"> </span><span class="n">grid</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">col</span><span class="ow">&lt;-</span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="p">(</span><span class="n">numCols</span><span class="o">-</span><span class="mi">1</span><span class="p">)]]</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">row</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="p">(</span><span class="n">numRows</span><span class="o">-</span><span class="mi">1</span><span class="p">)]]</span><span class="w">
     </span><span class="kr">where</span><span class="w"> </span><span class="n">numCols</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">head</span><span class="w"> </span><span class="n">grid</span><span class="w">
           </span><span class="n">numRows</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="n">grid</span><span class="w">

</span><span class="nf">numsToString</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[[</span><span class="kt">Int</span><span class="p">]]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="kt">String</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="kt">String</span><span class="p">]</span><span class="w">
</span><span class="nf">numsToString</span><span class="w"> </span><span class="n">nums</span><span class="w"> </span><span class="n">origMap</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">map</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="n">lineNums</span><span class="p">,</span><span class="w"> </span><span class="n">lineChars</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">map</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">s</span><span class="p">)</span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">resultToChar</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">zip</span><span class="w"> </span><span class="n">lineNums</span><span class="w"> </span><span class="n">lineChars</span><span class="p">)</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">zip</span><span class="w"> </span><span class="n">nums</span><span class="w"> </span><span class="n">origMap</span><span class="w">
    </span><span class="kr">where</span><span class="w"> </span><span class="n">digitToChar</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">chr</span><span class="p">(</span><span class="n">ord</span><span class="p">(</span><span class="sc">'0'</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">d</span><span class="p">)</span><span class="w">
          </span><span class="n">resultToChar</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="n">s</span><span class="o">==</span><span class="sc">'*'</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="sc">'*'</span><span class="w"> </span><span class="kr">else</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="n">n</span><span class="o">==</span><span class="mi">0</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="sc">' '</span><span class="w"> </span><span class="kr">else</span><span class="w"> </span><span class="p">(</span><span class="n">digitToChar</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w">


</span><span class="nf">annotate</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="kt">String</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="kt">String</span><span class="p">]</span><span class="w">
</span><span class="nf">annotate</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">[]</span><span class="w">
</span><span class="nf">annotate</span><span class="w"> </span><span class="n">grid</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">numsToString</span><span class="w"> </span><span class="p">(</span><span class="n">scoreGrid</span><span class="w"> </span><span class="n">grid</span><span class="p">)</span><span class="w"> </span><span class="n">grid</span>
</pre>
</div>
<div class="section" id="second-attempt">
<h3>Second attempt</h3>
<p>There are a few things I don't like about this first attempt</p>
<ul class="simple">
<li>We have a lot of <tt class="docutils literal">Int</tt> types floating around. Sometimes the are positions (rows, columns) and sometimes they are counts. It is hard to tell what argument goes where from the function signature.</li>
<li>The indexing into the list in <tt class="docutils literal">neighborhood</tt> feels inelegant</li>
<li>The process of getting of zipping two 2-D lists seems really cumbersome.</li>
</ul>
<p>The second point requires changing the entire algorithmic approach. Let's start by looking at the other two points.</p>
<div class="section" id="reducing-type-ambiguity">
<h4>Reducing type ambiguity</h4>
<p>The first point can be solved with a new typeclass, <tt class="docutils literal">Point</tt>.</p>
<pre class="code haskell literal-block">
<span class="kr">type</span><span class="w"> </span><span class="kt">Point</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="kt">Int</span><span class="p">,</span><span class="w"> </span><span class="kt">Int</span><span class="p">)</span><span class="w">

</span><span class="nf">neighborhood</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Point</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[[</span><span class="n">a</span><span class="p">]]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w">
</span><span class="nf">neighborhood</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">[]</span><span class="w">
</span><span class="nf">neighborhood</span><span class="w"> </span><span class="p">(</span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="n">col</span><span class="p">)</span><span class="w"> </span><span class="n">grid</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="n">grid</span><span class="w"> </span><span class="o">!!</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">!!</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">r</span><span class="ow">&lt;-</span><span class="p">[(</span><span class="n">row</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">..</span><span class="p">(</span><span class="n">row</span><span class="o">+</span><span class="mi">1</span><span class="p">)],</span><span class="w"> </span><span class="n">c</span><span class="ow">&lt;-</span><span class="p">[(</span><span class="n">col</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">..</span><span class="p">(</span><span class="n">col</span><span class="o">+</span><span class="mi">1</span><span class="p">)],</span><span class="w"> </span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">)</span><span class="o">/=</span><span class="p">(</span><span class="n">row</span><span class="p">,</span><span class="n">col</span><span class="p">),</span><span class="w"> </span><span class="n">r</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">r</span><span class="o">&lt;</span><span class="p">(</span><span class="n">length</span><span class="w"> </span><span class="n">grid</span><span class="p">),</span><span class="w"> </span><span class="n">c</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="o">&lt;</span><span class="n">length</span><span class="p">(</span><span class="n">grid</span><span class="o">!!</span><span class="mi">0</span><span class="p">)]</span><span class="w">

</span><span class="nf">scoreCell</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Point</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[[</span><span class="kt">Char</span><span class="p">]]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w">
</span><span class="nf">scoreCell</span><span class="w"> </span><span class="n">pt</span><span class="w"> </span><span class="n">grid</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">filter</span><span class="w"> </span><span class="p">(</span><span class="sc">'*'</span><span class="o">==</span><span class="p">)</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">neighborhood</span><span class="w"> </span><span class="n">pt</span><span class="w"> </span><span class="n">grid</span><span class="w">

</span><span class="nf">scoreGrid</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[[</span><span class="kt">Char</span><span class="p">]]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[[</span><span class="kt">Int</span><span class="p">]]</span><span class="w">
</span><span class="nf">scoreGrid</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">[]</span><span class="w">
</span><span class="nf">scoreGrid</span><span class="w"> </span><span class="n">grid</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[[</span><span class="n">scoreCell</span><span class="w"> </span><span class="p">(</span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="n">col</span><span class="p">)</span><span class="w"> </span><span class="n">grid</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">col</span><span class="ow">&lt;-</span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="p">(</span><span class="n">numCols</span><span class="o">-</span><span class="mi">1</span><span class="p">)]]</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">row</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="p">(</span><span class="n">numRows</span><span class="o">-</span><span class="mi">1</span><span class="p">)]]</span><span class="w">
   </span><span class="kr">where</span><span class="w"> </span><span class="n">numCols</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">head</span><span class="w"> </span><span class="n">grid</span><span class="w">
         </span><span class="n">numRows</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="n">grid</span>
</pre>
</div>
<div class="section" id="the-double-zipper">
<h4>The double zipper</h4>
<p>The line of code with two <tt class="docutils literal">zip</tt> calls and two <tt class="docutils literal">map</tt> calls is a little unweildy.</p>
<pre class="code haskell literal-block">
<span class="nf">numsToString</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[[</span><span class="kt">Int</span><span class="p">]]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="kt">String</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="kt">String</span><span class="p">]</span><span class="w">
</span><span class="nf">numsToString</span><span class="w"> </span><span class="n">nums</span><span class="w"> </span><span class="n">origMap</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">map</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="n">lineNums</span><span class="p">,</span><span class="w"> </span><span class="n">lineChars</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">map</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">s</span><span class="p">)</span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">resultToChar</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">zip</span><span class="w"> </span><span class="n">lineNums</span><span class="w"> </span><span class="n">lineChars</span><span class="p">)</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">zip</span><span class="w"> </span><span class="n">nums</span><span class="w"> </span><span class="n">origMap</span>
</pre>
<p>To understand what it is trying to do, recall it isn't quite enough to know the number of cells in the neighborhood that are mines. We also have to know which of the original
locations were mines.</p>
<p>Ultimately, what I want is a data structure like</p>
<pre class="code haskell literal-block">
<span class="c1">-- representing the board</span><span class="w">
</span><span class="c1">-- [&quot;  *&quot;,</span><span class="w">
</span><span class="c1">--  &quot;   &quot;]</span><span class="w">
</span><span class="nf">zipped</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="w">
   </span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span><span class="sc">' '</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="sc">' '</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="sc">'*'</span><span class="p">)],</span><span class="w">
   </span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span><span class="sc">' '</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="sc">' '</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="sc">' '</span><span class="p">)]</span><span class="w">
</span><span class="p">]</span>
</pre>
<p>Going tuple by tuple, if the second entry is <tt class="docutils literal">*</tt> this is what we should render.
If it is space, we should use the first element to determine what character to make (either a space or a digit).</p>
<p>Let's assume we have <tt class="docutils literal">zipped</tt> above, then our code would be</p>
<pre class="code haskell literal-block">
<span class="nf">render</span><span class="ow">::</span><span class="w"> </span><span class="p">[[(</span><span class="kt">Int</span><span class="p">,</span><span class="w"> </span><span class="kt">Char</span><span class="p">)]]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[[</span><span class="kt">Char</span><span class="p">]]</span><span class="w">
</span><span class="nf">render</span><span class="w"> </span><span class="n">zipped</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">map</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">line</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">map</span><span class="w"> </span><span class="p">(</span><span class="n">resultToCharTuple</span><span class="p">)</span><span class="w"> </span><span class="n">line</span><span class="p">)</span><span class="w"> </span><span class="n">zipped</span><span class="w">
    </span><span class="kr">where</span><span class="w"> </span><span class="n">resultToCharTuple</span><span class="w"> </span><span class="p">(</span><span class="kr">_</span><span class="p">,</span><span class="w"> </span><span class="sc">'*'</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="sc">'*'</span><span class="w">
          </span><span class="n">resultToCharTuple</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="kr">_</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="sc">' '</span><span class="w">
          </span><span class="n">resultToCharTuple</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="kr">_</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">chr</span><span class="p">(</span><span class="n">ord</span><span class="p">(</span><span class="sc">'0'</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">n</span><span class="p">)</span>
</pre>
<p>Constructing the zipped data structure requires a couple of steps. Using <tt class="docutils literal">zip</tt> zips the lines together:</p>
<pre class="code haskell literal-block">
<span class="nf">example</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="s">&quot;  *&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;   &quot;</span><span class="p">]</span><span class="w">
</span><span class="nf">scores</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span><span class="w">

</span><span class="nf">zip</span><span class="w"> </span><span class="n">scores</span><span class="w"> </span><span class="n">example</span><span class="w">
</span><span class="c1">-- [([0, 1, 1], &quot;  *&quot;), ([0, 1, 1], &quot;   &quot;)]</span>
</pre>
<p>To get the data structure I want, I'd have to map over this, and then zip the first and second entries of each tuple.</p>
<pre class="code haskell literal-block">
<span class="nf">map</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="n">one</span><span class="p">,</span><span class="w"> </span><span class="n">two</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">zip</span><span class="w"> </span><span class="n">one</span><span class="w"> </span><span class="n">two</span><span class="p">)</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">zip</span><span class="w"> </span><span class="n">scores</span><span class="w"> </span><span class="n">example</span><span class="w">
</span><span class="c1">-- [[(0,' '),(1,' '),(1,'*')],[(0,' '),(1,' '),(1,' ')]], i.e. zipped!</span>
</pre>
<p>Instead of doing this in two steps (creating the zipped structure and then reducing), we can also use the <tt class="docutils literal">zipWith</tt> function.
The purpose of zipWith is to take a function <tt class="docutils literal">a <span class="pre">-&gt;</span> b <span class="pre">-&gt;</span> c</tt> and use it to &quot;reduce&quot; the list while zipping. For example</p>
<pre class="code haskell literal-block">
<span class="nf">zipWith</span><span class="w"> </span><span class="p">(</span><span class="o">+</span><span class="p">)</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">20</span><span class="p">,</span><span class="w"> </span><span class="mi">30</span><span class="p">]</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">+</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">+</span><span class="mi">20</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="o">+</span><span class="mi">30</span><span class="p">]</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="mi">11</span><span class="p">,</span><span class="w"> </span><span class="mi">22</span><span class="p">,</span><span class="w"> </span><span class="mi">33</span><span class="p">]</span>
</pre>
<p>Let's start with a function that takes a row of scores, and a row of the original board:</p>
<pre class="code haskell literal-block">
<span class="nf">innerFunc</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="s">&quot;  *&quot;</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="o">???????</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="s">&quot; 1*&quot;</span>
</pre>
<p>If we are using <tt class="docutils literal">zipWith</tt>, we need a function that takes an <tt class="docutils literal">Int</tt> and a <tt class="docutils literal">Char</tt> and gives a <tt class="docutils literal">Char</tt>.
If we remove the tuple from <tt class="docutils literal">resultToChar</tt>, we already have our candidate!</p>
<pre class="code haskell literal-block">
<span class="nf">innerFunc</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="s">&quot;  *&quot;</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">zipWith</span><span class="w"> </span><span class="n">resultToChar</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="s">&quot;  *&quot;</span><span class="w">
</span><span class="c1">-- changing the helper function resultToChar to take two args, instead of a tuple</span><span class="w">
</span><span class="c1">-- i.e.</span><span class="w">
</span><span class="nf">innerFunc</span><span class="w"> </span><span class="n">scores</span><span class="w"> </span><span class="n">line</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">zipWith</span><span class="w"> </span><span class="n">resultToChar</span><span class="w"> </span><span class="n">scores</span><span class="w"> </span><span class="n">line</span>
</pre>
<p>We can change <tt class="docutils literal">numToStrings</tt></p>
<pre class="code haskell literal-block">
<span class="nf">numsToString</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[[</span><span class="kt">Int</span><span class="p">]]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="kt">String</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="kt">String</span><span class="p">]</span><span class="w">
</span><span class="nf">numsToString</span><span class="w"> </span><span class="n">nums</span><span class="w"> </span><span class="n">origMap</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">map</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="w"> </span><span class="p">(</span><span class="n">lineNums</span><span class="p">,</span><span class="w"> </span><span class="n">lineChars</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">zipWith</span><span class="w"> </span><span class="n">resultToChar</span><span class="w"> </span><span class="n">lineNums</span><span class="w"> </span><span class="n">lineChars</span><span class="p">)</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">zip</span><span class="w"> </span><span class="n">nums</span><span class="w"> </span><span class="n">origMap</span>
</pre>
<p>Notice that the reason we are zipping <tt class="docutils literal">nums</tt> and <tt class="docutils literal">origMap</tt> together is so we can map over the lists together.
We can eliminate the <tt class="docutils literal">map (f) $ zip a b</tt> pattern with <tt class="docutils literal">zipWith fmod a b</tt> to get a much simpler function, where <tt class="docutils literal">fmod</tt> is a version
of <tt class="docutils literal">f</tt> that takes two arguments (rather than one tuple with two entries)</p>
<pre class="code haskell literal-block">
<span class="nf">numsToString</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[[</span><span class="kt">Int</span><span class="p">]]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="kt">String</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="kt">String</span><span class="p">]</span><span class="w">
</span><span class="nf">numsToString</span><span class="w"> </span><span class="n">nums</span><span class="w"> </span><span class="n">origMap</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">zipWith</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="w"> </span><span class="n">lineNums</span><span class="w"> </span><span class="n">lineChars</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">zipWith</span><span class="w"> </span><span class="n">resultToChar</span><span class="w"> </span><span class="n">lineNums</span><span class="w"> </span><span class="n">lineChars</span><span class="p">)</span><span class="w"> </span><span class="n">nums</span><span class="w"> </span><span class="n">origMap</span>
</pre>
<p>We can even eliminate some names. In the lambda function on the inside, we are simply applying these arguments in the same order.
We can eliminate the lambda and reduce to</p>
<pre class="code haskell literal-block">
<span class="nf">numsToString</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[[</span><span class="kt">Int</span><span class="p">]]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="kt">String</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="kt">String</span><span class="p">]</span><span class="w">
</span><span class="nf">numsToString</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="n">origMap</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">zipWith</span><span class="w"> </span><span class="p">(</span><span class="n">zipWith</span><span class="w"> </span><span class="n">resultToChar</span><span class="p">)</span><span class="w"> </span><span class="n">nums</span><span class="w"> </span><span class="n">origMap</span>
</pre>
<p>If we want to, we can even eliminate all the explicit arguments. I like having them there, as it gives me the option to use meaningful names,
but we can reduce this to</p>
<pre class="code haskell literal-block">
<span class="nf">numsToString</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[[</span><span class="kt">Int</span><span class="p">]]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[[</span><span class="kt">String</span><span class="p">]]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[[</span><span class="kt">String</span><span class="p">]]</span><span class="w">
</span><span class="nf">numsToString</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">zipWith</span><span class="w"> </span><span class="p">(</span><span class="n">zipWith</span><span class="w"> </span><span class="n">resultToChar</span><span class="p">)</span>
</pre>
</div>
<div class="section" id="final-version-two">
<h4>Final version two</h4>
<p>Here is our second attempt at this problem in Haskell.</p>
<pre class="code haskell literal-block">
<span class="kr">module</span><span class="w"> </span><span class="nn">Minesweeper</span><span class="w"> </span><span class="p">(</span><span class="nf">annotate</span><span class="p">)</span><span class="w"> </span><span class="kr">where</span><span class="w">
</span><span class="kr">import</span><span class="w"> </span><span class="nn">Data.Char</span><span class="w">

</span><span class="kr">type</span><span class="w"> </span><span class="kt">Point</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">(</span><span class="kt">Int</span><span class="p">,</span><span class="w"> </span><span class="kt">Int</span><span class="p">)</span><span class="w">

</span><span class="nf">neighborhood</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Point</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[[</span><span class="n">a</span><span class="p">]]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w">
</span><span class="nf">neighborhood</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">[]</span><span class="w">
</span><span class="nf">neighborhood</span><span class="w"> </span><span class="p">(</span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="n">col</span><span class="p">)</span><span class="w"> </span><span class="n">grid</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="n">grid</span><span class="w"> </span><span class="o">!!</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">!!</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">r</span><span class="ow">&lt;-</span><span class="p">[(</span><span class="n">row</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">..</span><span class="p">(</span><span class="n">row</span><span class="o">+</span><span class="mi">1</span><span class="p">)],</span><span class="w"> </span><span class="n">c</span><span class="ow">&lt;-</span><span class="p">[(</span><span class="n">col</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">..</span><span class="p">(</span><span class="n">col</span><span class="o">+</span><span class="mi">1</span><span class="p">)],</span><span class="w"> </span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">)</span><span class="o">/=</span><span class="p">(</span><span class="n">row</span><span class="p">,</span><span class="n">col</span><span class="p">),</span><span class="w"> </span><span class="n">r</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">r</span><span class="o">&lt;</span><span class="p">(</span><span class="n">length</span><span class="w"> </span><span class="n">grid</span><span class="p">),</span><span class="w"> </span><span class="n">c</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="o">&lt;</span><span class="n">length</span><span class="p">(</span><span class="n">grid</span><span class="o">!!</span><span class="mi">0</span><span class="p">)]</span><span class="w">

</span><span class="nf">scoreCell</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Point</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[[</span><span class="kt">Char</span><span class="p">]]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w">
</span><span class="nf">scoreCell</span><span class="w"> </span><span class="n">pt</span><span class="w"> </span><span class="n">grid</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">filter</span><span class="w"> </span><span class="p">(</span><span class="sc">'*'</span><span class="o">==</span><span class="p">)</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">neighborhood</span><span class="w"> </span><span class="n">pt</span><span class="w"> </span><span class="n">grid</span><span class="w">

</span><span class="nf">scoreGrid</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[[</span><span class="kt">Char</span><span class="p">]]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[[</span><span class="kt">Int</span><span class="p">]]</span><span class="w">
</span><span class="nf">scoreGrid</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">[]</span><span class="w">
</span><span class="nf">scoreGrid</span><span class="w"> </span><span class="n">grid</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[[</span><span class="n">scoreCell</span><span class="w"> </span><span class="p">(</span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="n">col</span><span class="p">)</span><span class="w"> </span><span class="n">grid</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">col</span><span class="ow">&lt;-</span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="p">(</span><span class="n">numCols</span><span class="o">-</span><span class="mi">1</span><span class="p">)]]</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">row</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="p">(</span><span class="n">numRows</span><span class="o">-</span><span class="mi">1</span><span class="p">)]]</span><span class="w">
     </span><span class="kr">where</span><span class="w"> </span><span class="n">numCols</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="n">head</span><span class="w"> </span><span class="n">grid</span><span class="w">
           </span><span class="n">numRows</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="n">grid</span><span class="w">

</span><span class="nf">numsToString</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[[</span><span class="kt">Int</span><span class="p">]]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="kt">String</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="kt">String</span><span class="p">]</span><span class="w">
</span><span class="nf">numsToString</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">zipWith</span><span class="w"> </span><span class="p">(</span><span class="n">zipWith</span><span class="w"> </span><span class="n">resultToChar</span><span class="p">)</span><span class="w">
       </span><span class="kr">where</span><span class="w"> </span><span class="n">resultToChar</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="sc">'*'</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="sc">'*'</span><span class="w">
             </span><span class="n">resultToChar</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="sc">' '</span><span class="w">
             </span><span class="n">resultToChar</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">chr</span><span class="p">(</span><span class="n">ord</span><span class="p">(</span><span class="sc">'0'</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w">

</span><span class="nf">annotate</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="kt">String</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="kt">String</span><span class="p">]</span><span class="w">
</span><span class="nf">annotate</span><span class="w"> </span><span class="kt">[]</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">[]</span><span class="w">
</span><span class="nf">annotate</span><span class="w"> </span><span class="n">grid</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">numsToString</span><span class="w"> </span><span class="p">(</span><span class="n">scoreGrid</span><span class="w"> </span><span class="n">grid</span><span class="p">)</span><span class="w"> </span><span class="n">grid</span>
</pre>
</div>
</div>
<div class="section" id="commentary-on-haskell-versions">
<h3>Commentary on Haskell versions</h3>
<p>There were a few generalizable learnings here.
The biggest one was on the use of <tt class="docutils literal">zipWith</tt> and when to use it.</p>
<p>I have used it with 1-D lists before, but my natural inclination when looking at a pair of 2-D lists that I
wanted to zip together element-wise and then reduce actual made the problem harder.
The simpler version of the problem was to use <tt class="docutils literal">zipWith</tt> twice.
It also meant that I could write my functions as functions that took two arguments for the reduction step, instead
of artificially placing the arguments in a tuple.</p>
<p>If we do want to create an elementwise zip function, here is one way of doing it:</p>
<pre class="code haskell literal-block">
<span class="nf">elementWiseZip</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[[</span><span class="n">a</span><span class="p">]]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[[</span><span class="n">b</span><span class="p">]]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[[(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)]]</span><span class="w">
</span><span class="nf">elementWiseZip</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">zipWith</span><span class="w"> </span><span class="p">(</span><span class="n">zipWith</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="w"> </span><span class="n">one</span><span class="w"> </span><span class="n">two</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">one</span><span class="p">,</span><span class="w"> </span><span class="n">two</span><span class="p">)))</span>
</pre>
<p>but often times we can skip creating this function altogether and replace the inner lambda with a reducing function.</p>
<p>The second thing I noticed was that Python's <tt class="docutils literal">IndexError</tt> catching made dealing with the boundary conditions relatively straightforward.
The Haskell <tt class="docutils literal">neighborhood</tt> function has a lot of index checking built in:</p>
<pre class="code haskell literal-block">
<span class="nf">neighborhood</span><span class="w"> </span><span class="p">(</span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="n">col</span><span class="p">)</span><span class="w"> </span><span class="n">grid</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="n">grid</span><span class="w"> </span><span class="o">!!</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">!!</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">r</span><span class="ow">&lt;-</span><span class="p">[(</span><span class="n">row</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">..</span><span class="p">(</span><span class="n">row</span><span class="o">+</span><span class="mi">1</span><span class="p">)],</span><span class="w"> </span><span class="n">c</span><span class="ow">&lt;-</span><span class="p">[(</span><span class="n">col</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">..</span><span class="p">(</span><span class="n">col</span><span class="o">+</span><span class="mi">1</span><span class="p">)],</span><span class="w"> </span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">)</span><span class="o">/=</span><span class="p">(</span><span class="n">row</span><span class="p">,</span><span class="n">col</span><span class="p">),</span><span class="w"> </span><span class="n">r</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">r</span><span class="o">&lt;</span><span class="p">(</span><span class="n">length</span><span class="w"> </span><span class="n">grid</span><span class="p">),</span><span class="w"> </span><span class="n">c</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="o">&lt;</span><span class="n">length</span><span class="p">(</span><span class="n">grid</span><span class="o">!!</span><span class="mi">0</span><span class="p">)]</span>
</pre>
<p>We could separate this out into its own function, but it is something that was significantly easier in Python.</p>
</div>
</div>
                </article>
            </aside><!-- /#featured -->
                <section id="content" class="body">
                    <h1>Other articles</h1>
                    <hr />
                    <ol id="posts-list" class="hfeed">

            <li><article class="hentry">
                <header>
                    <h1><a href="https://kiwidamien.github.io/hs4py/converting-dna-to-rna.html" rel="bookmark"
                           title="Permalink to Converting DNA to RNA">Converting DNA to RNA</a></h1>
                </header>

                <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2023-07-08T13:00:00-07:00">
                Published: Sat 08 July 2023
        </abbr>

        <address class="vcard author">
                By                         <a class="url fn" href="https://kiwidamien.github.io/hs4py/author/damien-martin.html">Damien Martin</a>
        </address>
<p>In <a href="https://kiwidamien.github.io/hs4py/category/exercises.html">Exercises</a>.</p>

</footer><!-- /.post-info -->                <p class="first last">Looks at string conversion (similar to ciphers) but on a very limited alphabet (A, C, G, T). Shows how to deal with <tt class="docutils literal">Either</tt> as an error handling technique.</p>

                <a class="readmore" href="https://kiwidamien.github.io/hs4py/converting-dna-to-rna.html">read more</a>
                </div><!-- /.entry-content -->
            </article></li>

            <li><article class="hentry">
                <header>
                    <h1><a href="https://kiwidamien.github.io/hs4py/pascals-triangle-and-recursion.html" rel="bookmark"
                           title="Permalink to Pascal's triangle and recursion">Pascal's triangle and recursion</a></h1>
                </header>

                <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2023-07-03T00:00:00-07:00">
                Published: Mon 03 July 2023
        </abbr>

        <address class="vcard author">
                By                         <a class="url fn" href="https://kiwidamien.github.io/hs4py/author/damien-martin.html">Damien Martin</a>
        </address>
<p>In <a href="https://kiwidamien.github.io/hs4py/category/exercises.html">Exercises</a>.</p>

</footer><!-- /.post-info -->                <p class="first last">TBW</p>

                <a class="readmore" href="https://kiwidamien.github.io/hs4py/pascals-triangle-and-recursion.html">read more</a>
                </div><!-- /.entry-content -->
            </article></li>
                </ol><!-- /#posts-list -->
                </section><!-- /#content -->
        <section id="extras" class="body">
                <div class="blogroll">
                        <h2>links</h2>
                        <ul>
                            <li><a href="https://getpelican.com/">Pelican</a></li>
                            <li><a href="https://www.python.org/">Python.org</a></li>
                            <li><a href="https://palletsprojects.com/p/jinja/">Jinja2</a></li>
                            <li><a href="#">You can modify those links in your config file</a></li>
                        </ul>
                </div><!-- /.blogroll -->
                <div class="social">
                        <h2>social</h2>
                        <ul>
                            <li><a href="https://kiwidamien.github.io/hs4py/feeds/all.atom.xml" type="application/atom+xml" rel="alternate">atom feed</a></li>

                            <li><a href="#">You can add links in your config file</a></li>
                            <li><a href="#">Another social link</a></li>
                        </ul>
                </div><!-- /.social -->
        </section><!-- /#extras -->

        <footer id="contentinfo" class="body">
                <address id="about" class="vcard body">
                Proudly powered by <a href="https://getpelican.com/">Pelican</a>, which takes great advantage of <a href="https://www.python.org/">Python</a>.
                </address><!-- /#about -->

                <p>The theme is by <a href="https://www.smashingmagazine.com/2009/08/designing-a-html-5-layout-from-scratch/">Smashing Magazine</a>, thanks!</p>
        </footer><!-- /#contentinfo -->

</body>
</html>